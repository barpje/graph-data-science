#!/usr/bin/env rust-script
//! ```cargo
//! [dependencies]
//! clap="3"
//! gen_java = { git = "https://github.com/knutwalker/gen_java" }
//! ```

use std::num::NonZeroU32;

// java sizes
const LONG: u32 = std::mem::size_of::<u64>() as _;
const LONG_BITS: u32 = u64::BITS;
const BYTE_BITS: u32 = u8::BITS;

const fn number_of_x_per_bits(block_size: u32, bits: u32, x: u32) -> u32 {
    (block_size * bits + x - 1) / x
}

const fn number_of_words_for_bits(block_size: u32, bits: u32) -> u32 {
    number_of_x_per_bits(block_size, bits, LONG_BITS)
}

const fn number_of_bytes_for_bits(block_size: u32, bits: u32) -> u32 {
    number_of_x_per_bits(block_size, bits, BYTE_BITS)
}

const fn plural(n: u32) -> &'static str {
    if n == 1 {
        ""
    } else {
        "s"
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    fn parse_block_size(s: &str) -> Result<u32, String> {
        let bs = s.parse().map_err(|e| format!("must be a number: {e}"))?;

        if !(1..=LONG_BITS).contains(&bs) {
            return Err(format!("must be between 1 and {}", LONG_BITS));
        }

        if !bs.is_power_of_two() {
            return Err("must be a power of two".into());
        }

        Ok(bs)
    }

    let mut matches = clap::Command::new(file!())
        .arg(
            clap::Arg::new("block-size")
                .short('b')
                .long("block-size")
                .value_parser(parse_block_size)
                .default_value("64")
                .help("How many input values will be packed as a single block."),
        )
        .arg(
            clap::Arg::new("class-name")
                .short('c')
                .long("class-name")
                .value_parser(clap::builder::NonEmptyStringValueParser::new())
                .default_value("AdjacencyPacking")
                .help("Name of the generated class."),
        )
        .arg(
            clap::Arg::new("package")
                .short('p')
                .long("package")
                .value_parser(clap::builder::NonEmptyStringValueParser::new())
                .default_value("org.neo4j.gds.core.loading")
                .help("Package of the generated class."),
        )
        .get_matches();

    let block_size = matches
        .remove_one("block-size")
        .expect("has a default value");

    let class_name = matches
        .remove_one("class-name")
        .expect("has a default value");
    let package = matches.remove_one("package").expect("has a default value");

    let packers = (0..=block_size).map(|i| pack(block_size, i)).collect();
    let unpackers = (0..=block_size).map(|i| unpack(block_size, i)).collect();
    let class = Class {
        documentation: vec![
            format!("This class is generated by {}", file!()),
            String::new(),
            "Do not edit this file directly.".into(),
        ],
        name: class_name,
        block_size,
        packers,
        unpackers,
    };
    let file = File { package, class };

    java::write_file(file);

    Ok(())
}

struct Pack {
    word: u32,
    offset: u32,
    shift: u32,
}

enum Inst {
    Declare {
        word: u32,
    },
    DeclareAndInit {
        word: u32,
        offset: u32,
    },
    DefineMask {
        constant: u64,
    },
    Pack {
        pack: Pack,
    },
    PackSplit {
        lower: Pack,
        upper_word: u32,
        upper_shift: u32,
    },
    _PackDelta {
        _pack: Pack,
        _previous: Option<NonZeroU32>,
    },
    _PackSplitDelta {
        _lower: Pack,
        _upper_word: u32,
        _upper_shift: u32,
        _previous: Option<NonZeroU32>,
    },
    Unpack {
        pack: Pack,
    },
    UnpackSplit {
        lower: Pack,
        upper_word: u32,
        upper_shift: u32,
    },
    _UnpackDelta {
        _pack: Pack,
        _previous: Option<NonZeroU32>,
    },
    _UnpackSplitDelta {
        _lower: Pack,
        _upper_word: u32,
        _upper_shift: u32,
        _previous: Option<NonZeroU32>,
    },
    Memset {
        size: u32,
        constant: u64,
    },
    Write {
        word: u32,
        offset: u32,
    },
    Return {
        offset: u32,
    },
}

struct CodeBlock {
    comment: Option<String>,
    code: Vec<Inst>,
}

struct Method {
    documentation: Vec<String>,
    prefix: &'static str,
    bits: u32,
    code: Vec<CodeBlock>,
}

struct Class {
    documentation: Vec<String>,
    name: String,
    block_size: u32,
    packers: Vec<Method>,
    unpackers: Vec<Method>,
}

struct File {
    package: String,
    class: Class,
}

fn pack(block_size: u32, bits: u32) -> Method {
    let words = number_of_words_for_bits(block_size, bits);
    let bytes = number_of_bytes_for_bits(block_size, bits);

    let mut code = Vec::new();

    code.push(CodeBlock {
        comment: Some(format!("Touching {words} word{}", plural(words))),
        code: (0..words).map(|i| Inst::Declare { word: i }).collect(),
    });

    if bits != 0 {
        code.push(CodeBlock {
            comment: None,
            code: (0..block_size).map(|i| single_pack(bits, i)).collect(),
        });
    }

    code.push(CodeBlock {
        comment: Some(format!("Write to {} byte{}", bytes, plural(bytes))),
        code: (0..words)
            .map(|word| Inst::Write {
                word,
                offset: word * LONG,
            })
            .collect(),
    });

    code.push(CodeBlock {
        comment: None,
        code: vec![Inst::Return { offset: bytes }],
    });

    Method {
        documentation: vec![format!(
            "Packs {block_size} {bits}-bit value{} into {bytes} byte{}, touching {words} word{}.",
            plural(block_size),
            plural(bytes),
            plural(words),
        )],
        prefix: "pack",
        bits,
        code,
    }
}

fn unpack(block_size: u32, bits: u32) -> Method {
    let words = number_of_words_for_bits(block_size, bits);
    let bytes = number_of_bytes_for_bits(block_size, bits);

    let mut code = Vec::new();

    code.push(CodeBlock {
        comment: Some(format!("Access {words} word{}", plural(words))),
        code: (0..words)
            .map(|word| Inst::DeclareAndInit {
                word,
                offset: word * LONG,
            })
            .collect(),
    });

    if bits == 0 {
        code.push(CodeBlock {
            comment: None,
            code: vec![Inst::Memset {
                size: block_size,
                constant: 0,
            }],
        });
    } else {
        code.push(CodeBlock {
            comment: None,
            code: (0..block_size)
                .map(|i| {
                    let pack = single_pack(bits, i);
                    match pack {
                        Inst::Pack { pack } => Inst::Unpack { pack },
                        Inst::PackSplit {
                            lower,
                            upper_word,
                            upper_shift,
                        } => Inst::UnpackSplit {
                            lower,
                            upper_word,
                            upper_shift,
                        },
                        Inst::_PackDelta {
                            _pack: pack,
                            _previous: previous,
                        } => Inst::_UnpackDelta {
                            _pack: pack,
                            _previous: previous,
                        },
                        Inst::_PackSplitDelta {
                            _lower: lower,
                            _upper_word: upper_word,
                            _upper_shift: upper_shift,
                            _previous: previous,
                        } => Inst::_UnpackSplitDelta {
                            _lower: lower,
                            _upper_word: upper_word,
                            _upper_shift: upper_shift,
                            _previous: previous,
                        },
                        _ => unreachable!(),
                    }
                })
                .collect(),
        });

        if bits != block_size {
            let mask = (1_u64 << bits) - 1;

            code.last_mut()
                .unwrap()
                .code
                .insert(0, Inst::DefineMask { constant: mask });
        }
    }

    code.push(CodeBlock {
        comment: None,
        code: vec![Inst::Return { offset: bytes }],
    });

    Method {
        documentation: vec![format!(
            "Unpacks {block_size} {bits}-bit value{} using {bytes} byte{}, touching {words} word{}.",
            plural(block_size),
            plural(bytes),
            plural(words),
        )],
        prefix: "unpack",
        bits,
        code,
    }
}

fn single_pack(bits: u32, offset: u32) -> Inst {
    // how many bits we need to shift the current value to get to its position
    let shift = (offset * bits) % LONG_BITS;
    // the word for the lower bits of the current value
    let lower_word = offset * bits / LONG_BITS;
    // the word for the upper bits of the current value
    let upper_word = (offset * bits + bits - 1) / LONG_BITS;

    let pack = Pack {
        word: lower_word,
        offset,
        shift,
    };

    if lower_word == upper_word {
        // value fits within one word
        Inst::Pack { pack }
    } else {
        // need to split the value across multiple words
        Inst::PackSplit {
            lower: pack,
            upper_word,
            upper_shift: LONG_BITS - shift,
        }
    }
}

mod java {
    use super::*;
    use gen_java::*;

    const PIN: &str = "values";
    const OFF: &str = "valuesStart";
    const PW: &str = "packedPtr";
    const BITS: &str = "bits";

    const BS: &str = "BLOCK_SIZE";
    const PACKERS: &str = "PACKERS";
    const UNPACKERS: &str = "UNPACKERS";

    const PIN_PARAM: Param = Param {
        typ: "long[]",
        ident: PIN,
    };
    const OFF_PARAM: Param = Param {
        typ: "int",
        ident: OFF,
    };
    const PW_PARAM: Param = Param {
        typ: "long",
        ident: PW,
    };

    const PARAMS: [Param; 3] = [PIN_PARAM, OFF_PARAM, PW_PARAM];

    const FULL_PARAMS: [Param; 4] = [
        Param {
            typ: "int",
            ident: BITS,
        },
        PIN_PARAM,
        OFF_PARAM,
        PW_PARAM,
    ];

    fn gen_method(method: Method) -> MethodDef {
        fn value(offset: u32) -> Expr {
            Expr::bin(
                Expr::Ident(PIN),
                BinOp::Index,
                Expr::bin(Expr::Literal(offset), BinOp::Add, Expr::Ident(OFF)),
            )
        }

        let ident = |word: u32| -> String { format!("w{word}") };
        let mut mask = u64::MAX;
        let mut statements = Vec::new();

        for code in method.code {
            if code.code.is_empty() {
                continue;
            }

            if let Some(comment) = code.comment {
                statements.push(Stmt::Comment(comment));
            }

            for inst in code.code {
                match inst {
                    Inst::Declare { word } => {
                        statements.push(Stmt::Def(Def {
                            typ: "long",
                            ident: ident(word),
                            value: None,
                        }));
                    }
                    Inst::DeclareAndInit { word, offset } => {
                        statements.push(Stmt::Def(Def {
                            typ: "long",
                            ident: ident(word),
                            value: Some(Expr::Call(Call::new(
                                Expr::Ident("UnsafeUtil"),
                                "getLong",
                                vec![Arg::new(Expr::bin(
                                    Expr::Literal(offset),
                                    BinOp::Add,
                                    Expr::Ident(PW),
                                ))],
                            ))),
                        }));
                    }
                    Inst::DefineMask { constant } => {
                        mask = constant;
                    }
                    Inst::Pack {
                        pack:
                            Pack {
                                word,
                                offset,
                                shift,
                            },
                    } => {
                        let value = Expr::bin(value(offset), BinOp::Shl, Expr::Literal(shift));
                        if shift == 0 {
                            statements.push(Stmt::Assign {
                                lhs: Expr::Var(ident(word)),
                                rhs: value,
                            });
                        } else {
                            statements.push(Stmt::Expr(Expr::bin(
                                Expr::Var(ident(word)),
                                BinOp::OrAssign,
                                value,
                            )));
                        }
                    }
                    Inst::PackSplit {
                        lower:
                            Pack {
                                word: lower_word,
                                offset,
                                shift: lower_shift,
                            },
                        upper_word,
                        upper_shift,
                    } => {
                        statements.push(Stmt::Expr(Expr::bin(
                            Expr::Var(ident(lower_word)),
                            BinOp::OrAssign,
                            Expr::bin(value(offset), BinOp::Shl, Expr::Literal(lower_shift)),
                        )));

                        statements.push(Stmt::Assign {
                            lhs: Expr::Var(ident(upper_word)),
                            rhs: Expr::bin(value(offset), BinOp::Shr, Expr::Literal(upper_shift)),
                        });
                    }
                    Inst::_PackDelta {
                        _pack:
                            Pack {
                                word: _,
                                offset: _,
                                shift: _,
                            },
                        _previous,
                    } => {
                        todo!()
                    }
                    Inst::_PackSplitDelta {
                        _lower:
                            Pack {
                                word: _lower_word,
                                offset: _,
                                shift: _lower_shift,
                            },
                        _upper_word,
                        _upper_shift,
                        _previous,
                    } => {
                        todo!()
                    }
                    Inst::Unpack {
                        pack:
                            Pack {
                                word,
                                offset,
                                shift,
                            },
                    } => {
                        let shift_expr =
                            Expr::bin(Expr::Var(ident(word)), BinOp::Shr, Expr::Literal(shift));

                        let mask = if shift + method.bits == LONG_BITS {
                            shift_expr
                        } else {
                            Expr::bin(shift_expr, BinOp::And, Expr::HexLiteral(mask))
                        };

                        statements.push(Stmt::Assign {
                            lhs: value(offset),
                            rhs: mask,
                        });
                    }
                    Inst::UnpackSplit {
                        lower:
                            Pack {
                                word: lower_word,
                                offset,
                                shift: lower_shift,
                            },
                        upper_word,
                        upper_shift,
                    } => {
                        statements.push(Stmt::Assign {
                            lhs: value(offset),
                            rhs: Expr::bin(
                                Expr::bin(
                                    Expr::bin(
                                        Expr::Var(ident(lower_word)),
                                        BinOp::Shr,
                                        Expr::Literal(lower_shift),
                                    ),
                                    BinOp::Or,
                                    Expr::bin(
                                        Expr::Var(ident(upper_word)),
                                        BinOp::Shl,
                                        Expr::Literal(upper_shift),
                                    ),
                                ),
                                BinOp::And,
                                Expr::HexLiteral(mask),
                            ),
                        });
                    }
                    Inst::_UnpackDelta {
                        _pack:
                            Pack {
                                word: _,
                                offset: _,
                                shift: _,
                            },
                        _previous,
                    } => {
                        todo!()
                    }
                    Inst::_UnpackSplitDelta {
                        _lower:
                            Pack {
                                word: _lower_word,
                                offset: _,
                                shift: _lower_shift,
                            },
                        _upper_word,
                        _upper_shift,
                        _previous,
                    } => {
                        todo!()
                    }
                    Inst::Memset { size, constant } => {
                        statements.push(Stmt::Expr(Expr::Call(Call::new(
                            Expr::Ident("java.util.Arrays"),
                            "fill",
                            vec![
                                Arg::new(Expr::Ident(PIN)),
                                Arg::new(Expr::Ident(OFF)),
                                Arg::new(Expr::bin(
                                    Expr::Ident(OFF),
                                    BinOp::Add,
                                    Expr::Literal(size),
                                )),
                                Arg::new(Expr::HexLiteral(constant)),
                            ],
                        ))));
                    }
                    Inst::Write { word, offset } => {
                        statements.push(Stmt::Expr(Expr::Call(Call::new(
                            Expr::Ident("UnsafeUtil"),
                            "putLong",
                            vec![
                                Arg::new(Expr::bin(
                                    Expr::Literal(offset),
                                    BinOp::Add,
                                    Expr::Ident(PW),
                                )),
                                Arg::new(Expr::Var(ident(word))),
                            ],
                        ))));
                    }
                    Inst::Return { offset } => {
                        statements.push(Stmt::Return {
                            value: Expr::bin(Expr::Literal(offset), BinOp::Add, Expr::Ident(PW)),
                        });
                    }
                }
            }
        }

        let doc = method.documentation.join("\n");
        let ident = format!("{prefix}{bits}", prefix = method.prefix, bits = method.bits);

        MethodDef {
            documentation: Some(doc),
            modifiers: "private static",
            typ: "long",
            ident,
            params: &PARAMS,
            code: Some(statements),
        }
    }

    fn gen_class(class: Class) -> ClassDef {
        let mut members = Vec::new();

        members.push(Member::Method(MethodDef {
            documentation: None,
            modifiers: "private",
            typ: "",
            ident: class.name.clone(),
            params: &[],
            code: Some(vec![]),
        }));

        members.push(Member::Def(Def {
            typ: "public static final int",
            ident: BS.into(),
            value: Some(Expr::Literal(class.block_size)),
        }));

        members.push(Member::Method(MethodDef {
            documentation: None,
            modifiers: "public static",
            typ: "int",
            ident: "advanceValueOffset".into(),
            params: &[Param {
                typ: "int",
                ident: OFF,
            }],
            code: Some(vec![Stmt::Return {
                value: Expr::bin(Expr::Ident(OFF), BinOp::Add, Expr::Ident(BS)),
            }]),
        }));

        members.push(Member::Method(MethodDef {
            documentation: None,
            modifiers: "public static",
            typ: "long",
            ident: "pack".into(),
            params: &FULL_PARAMS,
            code: Some(vec![
                Stmt::Assert {
                    assertion: Expr::bin(
                        Expr::Ident(BITS),
                        BinOp::Lte,
                        Expr::Literal(class.block_size),
                    ),
                    message: Some(Expr::bin(
                        Expr::StringLit(format!(
                            "Bits must be at most {bs} but was ",
                            bs = class.block_size
                        )),
                        BinOp::Add,
                        Expr::Ident(BITS),
                    )),
                },
                Stmt::Return {
                    value: Expr::Call(Call::new(
                        Expr::bin(Expr::Ident(PACKERS), BinOp::Index, Expr::Ident(BITS)),
                        "pack",
                        vec![
                            Arg::new(Expr::Ident(PIN)),
                            Arg::new(Expr::Ident(OFF)),
                            Arg::new(Expr::Ident(PW)),
                        ],
                    )),
                },
            ]),
        }));

        members.push(Member::Method(MethodDef {
            documentation: None,
            modifiers: "public static",
            typ: "long",
            ident: "unpack".into(),
            params: &FULL_PARAMS,
            code: Some(vec![
                Stmt::Assert {
                    assertion: Expr::bin(
                        Expr::Ident(BITS),
                        BinOp::Lte,
                        Expr::Literal(class.block_size),
                    ),
                    message: Some(Expr::bin(
                        Expr::StringLit(format!(
                            "Bits must be at most {bs} but was ",
                            bs = class.block_size
                        )),
                        BinOp::Add,
                        Expr::Ident(BITS),
                    )),
                },
                Stmt::Return {
                    value: Expr::Call(Call::new(
                        Expr::bin(Expr::Ident(UNPACKERS), BinOp::Index, Expr::Ident(BITS)),
                        "unpack",
                        vec![
                            Arg::new(Expr::Ident(PIN)),
                            Arg::new(Expr::Ident(OFF)),
                            Arg::new(Expr::Ident(PW)),
                        ],
                    )),
                },
            ]),
        }));

        members.push(Member::Class(ClassDef {
            documentation: None,
            annotations: vec![Call::new(Expr::NoOp, "FunctionalInterface", Vec::new())],
            modifiers: "private",
            typ: "interface",
            name: "Packer".into(),
            members: vec![Member::Method(MethodDef {
                documentation: None,
                modifiers: "",
                typ: "long",
                ident: "pack".into(),
                params: &PARAMS,
                code: None,
            })],
        }));

        members.push(Member::Class(ClassDef {
            documentation: None,
            annotations: vec![Call::new(Expr::NoOp, "FunctionalInterface", Vec::new())],
            modifiers: "private",
            typ: "interface",
            name: "Unpacker".into(),
            members: vec![Member::Method(MethodDef {
                documentation: None,
                modifiers: "",
                typ: "long",
                ident: "unpack".into(),
                params: &PARAMS,
                code: None,
            })],
        }));

        members.push(Member::Def(Def {
            typ: "private static final Packer[]",
            ident: PACKERS.into(),
            value: Some(Expr::ArrayInit(
                class
                    .packers
                    .iter()
                    .map(|p| {
                        Expr::MethodRef(Call::new(
                            Expr::Var(class.name.clone()),
                            format!("{}{}", p.prefix, p.bits),
                            Vec::new(),
                        ))
                    })
                    .collect(),
            )),
        }));

        members.push(Member::Def(Def {
            typ: "private static final Unpacker[]",
            ident: UNPACKERS.into(),
            value: Some(Expr::ArrayInit(
                class
                    .unpackers
                    .iter()
                    .map(|p| {
                        Expr::MethodRef(Call::new(
                            Expr::Var(class.name.clone()),
                            format!("{}{}", p.prefix, p.bits),
                            Vec::new(),
                        ))
                    })
                    .collect(),
            )),
        }));

        members.extend(
            class
                .packers
                .into_iter()
                .chain(class.unpackers)
                .map(gen_method)
                .map(Member::Method),
        );

        let doc = class.documentation.join("\n");

        ClassDef {
            documentation: Some(doc),
            annotations: Vec::new(),
            modifiers: "public final",
            typ: "class",
            name: class.name,
            members,
        }
    }

    fn gen_file(file: File) -> FileDef {
        let class = gen_class(file.class);
        let mut file = FileDef::new(
            r#"
Copyright (c) "Neo4j"
Neo4j Sweden AB [http://neo4j.com]

This file is part of Neo4j.

Neo4j is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"#,
            file.package,
            vec!["org.neo4j.internal.unsafe.UnsafeUtil".into()],
            class,
        );

        file.optimize();
        file
    }

    pub(super) fn write_file(file: File) {
        let file = gen_file(file);

        let mut writer = FileWriter::new(0);
        file.print(&mut writer);
        print!("{}", writer.into_inner());
    }
}
